import numpy as np
from scipy.optimize import root
import matplotlib.pyplot as plt

N = 50
gamma1 = 0
gamma2 = 3
bcs = [gamma1, gamma2]
a = 0
b = -0.5
dx = (gamma2 - gamma1) / N  # grid spacing
x = np.linspace(gamma1, gamma2, N + 1)  # grid points
u0 = np.zeros(N + 1)  # initial guess

def func(u, bcs, dx, N):
    F = np.zeros(N + 1)
    F[0] = (u[1] - 2 * u[0] + bcs[0]) / dx ** 2

    for i in range(1, N - 1):
        F[i] = (u[i + 1] - 2 * u[i] + u[i - 1]) / dx ** 2

    F[N] = (bcs[1] - 2 * u[N] + u[N - 1]) / dx ** 2

    return F

sol = root(func, u0, args=(bcs, dx, N))

def exact_sol(x):
    return ((gamma2 - gamma1) / (b - a)) * (x - a) + gamma1


plt.plot(x, sol.x, label="Numerical solution")
plt.plot(x, exact_sol(x), label="Exact solution")
plt.legend()
plt.show()

#%% q2

def generate_tridiagonal_matrix(N, a, b, c):
    A = np.zeros((N, N))
    for i in range(N):
        A[i, i] = b
        if i > 0:
            A[i, i - 1] = a
        if i < N - 1:
            A[i, i + 1] = c
    return A


## OTHER ATTEMPT

def generate_tridiagonal_matrix(N, dx, dt, alpha):
    r = alpha*dt/(dx*dx) 
    A = np.zeros((N, N))# 
    b = np.zeros(N)
    for i in range(1, N-1):
        A[i, i-1] = -r
        A[i, i] = 1 + 2*r
        A[i, i+1] = -r
    A[0, 0] = 1
    A[N-1, N-1] = 1
    b[0] = 0
    b[N-1] = 0
    return A, b

def solve_diffusion_equation(u0, N, dx, dt, alpha, T):
    u = u0.copy()
    for n in range(int(T/dt)):
        A, b = generate_tridiagonal_matrix(N, dx, dt, alpha)
        u = np.linalg.solve(A, u + b)
    return u

# Example usage
N = 101
dx = 0.01
dt = 0.001
alpha = 0.1
T = 1.0
x = np.linspace(0, 1, N)
u0 = np.sin(np.pi*x)
u = solve_diffusion_equation(u0, N, dx, dt, alpha, T)

# Plot the solution
import matplotlib.pyplot as plt
plt.plot(x, u)
plt.xlabel('x')
plt.ylabel('u')
plt.show()
from scipy.optimize import root
import numpy as np
import matplotlib.pyplot as plt


#defining exact solution to test code on
def u(x,a, b, gamma1, gamma2):
    return ((gamma2 - gamma1) / (b-a)) * (x-a) + gamma1

def u_two(x,a, b, gamma1, gamma2):
    return ((-1/2)*(x-a)*(x-b) + ((gamma2-gamma1)/ (b-a))) * (x-a) + gamma1 

#number of finite grid points (minus one)
N = 20

#problem parameters -- these need to be varied but what are the limits???
#test with different values of a, b, gamma1, gamma2
#starting with 0,1,0,1 for simplicity
a = 0
b = 1

gamma1 = 0.0
gamma2 = 1.0

#creating the grid of finite points
x = np.linspace(a,b,N+1)
dx = (b-a) / N

#extracting the interior points
x_int = x[1:-1]


#define function LHS of problem to solve
def dirichlet_problem(u, N, dx, gamma1, gamma2):
    func = np.zeros(N-1)

    func[0] = (u[1] - 2*u[0] + gamma1) / dx**2

    for i in range(1, N-2):
        func[i] = (u[i+1] - 2 * u[i] + u[i-1]) / dx**2
    
    func[N-2] = (gamma2 - 2 * u[N-2] + u[N-3]) / dx**2

    return func

def func_source_term(u, N, dx, gamma1, gamma2, f):
    bcs = [gamma1, gamma2]
    F = np.zeros(N - 1)
    F[0] = (u[1] - 2 * u[0] + bcs[0]) / dx ** 2 - f[0]

    for i in range(1, N - 2):
        F[i] = (u[i + 1] - 2 * u[i] + u[i - 1]) / dx ** 2 - f[i]

    F[N-2] = (bcs[1] - 2 * u[N-2] + u[N - 3]) / dx ** 2 - f[N-2]

    return F

#setting initial guess --- what do we want to multiply x_int by?
u_guess =  0.2 * x_int

#solve the problem using root & print message to indicate success
sol = root(func_source_term, u_guess, args=(N, dx, gamma1, gamma2, np.sin(x_int)))

# solution at the interior grid points
u_int = sol.x

u_true = u_two(x, a, b, gamma1, gamma2)

#plot numerical solution

plt.plot(x_int, u_int, '.', label="Numerical solution")
plt.plot(x, u_true, 'k', label='Exact solution')

plt.xlabel(f'$x$')
plt.ylabel(f'$u(x)$')
plt.legend()
plt.show()

from __future__ import division
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import fsolve





def npc(f, u0, pars, vary_min, discretisation='shooting',solver=fsolve, pc='none'):
    
    # Generate an array of parameter values to use in the continuation. Done back-to-front of sorts. 
    #step set to 50, can reduce this to reduce time, however reduces resolution.
    parameter_array = np.linspace(pars[0], vary_min, 30)

    # Initialize an empty list to store the solutions.
    sol_list = []
    
    # Iterate over the parameter values.
    for i in parameter_array:
        # Update the parameter value in `pars`.
        pars.__setitem__(0, i)
  
        
        # Set the initial conditions for the ODE system.
        initial_pars0 = (pc or '') and ((pc or '') != 'none') and (pc, pars) or pars

        
        # Solve the ODE system using the specified method and solver.
        sol = np.array(solver(discretisation(f), u0, args=initial_pars0))

        # Append the solution to the list of solutions.
        sol_list.append(sol)

        # Set the initial conditions for the next step to be the current solution.
        u0 = sol
    
    # Return the parameter values and the list of solutions as a tuple.
    return parameter_array, np.array(sol_list)

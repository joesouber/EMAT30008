import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
import numdifftools as nd
from scipy.optimize import fsolve

#%% Need to get this working!
def shoot(ODE):
    """ 
    Function taking only the ODE as argument, contaning G. Allowing it to be a called as the argument
    for fsolve, with the parameters of G to be the arguments.
        Parameters:
                ODE (function):     ODE for which the shooting problem is to be solved
        Output:
                G:                  Array containing estimates for starting condions and the time period
        """

    def G(U, pc, *args):
        """
        Returns the difference between the initial conditions and the solution to the ODE,
        and finds the phase condition.
            Parameters:
                    U(tuple):               Tuple containing the estimate of the starting conditions and time period
                    pc(function)            The phase condition function specified to be used
                    args:                   Any additional arguments required for the ODE
            Output:
                    gsol:                   Array containing estimates for starting condions and the time period
        """    
        # unpack U
        u0 = U[:-1]
        T = U[-1]
        

        # check shape 
        if len(u0) > 1:
            system = True
        else:
            system = False

        # solve ode for given estimates
        sol = solve_ivp(ODE, [0, T], u0,method='RK45')
        g1 = u0 - sol[-1]
        g2 = pc(u0, *args)   
        gsol = np.append(g1, g2)

        return gsol

    return G


def limit_cycle(ODE ,U0, pc,*args):
    """
    Solves the shooting problem to find the roots to G, hence u0 and T which are
    the conditions to make a limit cycle
        Parameters:
                ODE (function):         The ODE of which the limit cycle is to be found
                U0 (tuple):             The estimated initial conditions and time period of the ODE limit cycle
                pc(function)            The phase condition function specified to be used
                args:                   Any additional arguments required for the ODE
                
        Returns:
                u0 (tuple):             Initial conditions of the limit cycle
                T (float):              Time period of the limit cycle
    """
    
    sol = fsolve(shoot(ODE),U0,args=(pc,*args))        
    return sol          


def conditions(f, u0, var, *args):
    """Calculates the phase condition of the ODEs using f(0, u0)[var]
Parameters
----------
f   : function
     Function of given ODE(s) that returns the derivative at f(t, x)
u0  : array
     ODE initial conditions
var : integer
     User specified choice of variable for phase condition
Returns
-------
phase_cond : array
            Phase condition for shooting
"""


    phase_cond = np.array([f(0, u0, *args)[var]])
    return phase_cond






#%%Exercise 1 

def pred_prey_eq(X, pars):
  
    x = X[0]
    y = X[1]
    a, b, d = pars[0], pars[1], pars[2]
    dxdt = x * (1 - x) - (a * x * y) / (d + x)
    dydt = b * y * (1 - (y / x))
    return np.array([dxdt, dydt])

a = 1
d = 0.1 
b= 0.1



pars = [a, b, d]
X0 = [0.5, 0.5]
t_eval = np.linspace(0, 200, 1000)
sol = solve_ivp(lambda t, X: pred_prey_eq(X, pars), [0, 200], X0, t_eval=t_eval)





plt.plot(sol.t, sol.y[0], label='Predator population')
plt.plot(sol.t, sol.y[1], label='Prey population')
plt.legend()
plt.xlabel('Time')
plt.ylabel('Population')
plt.show()


x = np.linspace(0, 1, 20)
y = np.linspace(0, 1, 20)
X, Y = np.meshgrid(x, y)
DX, DY = pred_prey_eq([X, Y], pars)
fig, ax = plt.subplots()
ax.streamplot(X, Y, DX, DY, color='red')
ax.set_xlabel('Prey population')
ax.set_ylabel('Predator population')

plt.show()


